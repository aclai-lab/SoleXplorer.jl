var documenterSearchIndex = {"docs":
[{"location":"dataset/#setup-dataset","page":"Setup Dataset","title":"Setup dataset","text":"","category":"section"},{"location":"dataset/#SoleXplorer.setup_dataset-Tuple{}","page":"Setup Dataset","title":"SoleXplorer.setup_dataset","text":"setup_dataset(\n    X, y, w=nothing;\n    model=_DefaultModel(y),\n    resampling=Holdout(fraction_train=0.7, shuffle=true),\n    valid_ratio=0.0,\n    seed=nothing,\n    balancing=nothing,\n    tuning=nothing,\n    win=AdaptiveWindow(nwindows=3, relative_overlap=0.1),\n    features=(maximum, minimum),\n    modalreduce=mean,\n) -> AbstractDataSet\n\nCreates and configures a dataset structure for machine learning.\n\nThis is the core implementation function that handles the complete dataset setup pipeline, including data preprocessing, model configuration, partitioning, hyperparameter tuning, and MLJ machine creation.\n\nArguments\n\nX::AbstractDataFrame: Feature matrix/DataFrame\ny::AbstractVector: Target variable vector\nw::MaybeVector=nothing: Optional sample weights\n\nKeyword Arguments\n\nModel Configuration\n\nmodel::MLJ.Model=_DefaultModel(y): Sole compatible MLJ model to use,   auto-selected based on target type, if no model is subbmitted\n\nAvailable Models\n\nFrom package Bensadoun, R., et al. (2013). DecisionTree.jl:\n\nDecisionTreeClassifier(\n  max_depth = -1, \n  min_samples_leaf = 1, \n  min_samples_split = 2, \n  min_purity_increase = 0.0, \n  n_subfeatures = 0, \n  post_prune = false, \n  merge_purity_threshold = 1.0, \n  display_depth = 5, \n  feature_importance = :impurity, \n  rng = Random.TaskLocalRNG())\n\nDecisionTreeRegressor(\n  max_depth = -1, \n  min_samples_leaf = 5, \n  min_samples_split = 2, \n  min_purity_increase = 0.0, \n  n_subfeatures = 0, \n  post_prune = false, \n  merge_purity_threshold = 1.0, \n  feature_importance = :impurity, \n  rng = Random.TaskLocalRNG())\n\nRandomForestClassifier(\n  max_depth = -1, \n  min_samples_leaf = 1, \n  min_samples_split = 2, \n  min_purity_increase = 0.0, \n  n_subfeatures = -1, \n  n_trees = 100, \n  sampling_fraction = 0.7, \n  feature_importance = :impurity, \n  rng = Random.TaskLocalRNG())\n\nRandomForestRegressor(\n  max_depth = -1, \n  min_samples_leaf = 1, \n  min_samples_split = 2, \n  min_purity_increase = 0.0, \n  n_subfeatures = -1, \n  n_trees = 100, \n  sampling_fraction = 0.7, \n  feature_importance = :impurity, \n  rng = Random.TaskLocalRNG())\n\nAdaBoostStumpClassifier(\n  n_iter = 10, \n  feature_importance = :impurity, \n  rng = Random.TaskLocalRNG())\n\nFrom package ACLAI Lab and G. Pagliarini (2023). ModalDecisionTrees.jl:\n\nModalDecisionTree(\n  max_depth = nothing, \n  min_samples_leaf = 4, \n  min_purity_increase = 0.002, \n  max_purity_at_leaf = Inf, \n  max_modal_depth = nothing, \n  relations = nothing, \n  features = nothing, \n  conditions = nothing, \n  featvaltype = Float64, \n  initconditions = nothing, \n  downsize = SoleData.var\"#downsize#541\"(), \n  force_i_variables = true, \n  fixcallablenans = false, \n  print_progress = false, \n  rng = Random.TaskLocalRNG(), \n  display_depth = nothing, \n  min_samples_split = nothing, \n  n_subfeatures = identity, \n  post_prune = false, \n  merge_purity_threshold = nothing, \n  feature_importance = :split)\n\nModalRandomForest(\n  sampling_fraction = 0.7, \n  ntrees = 10, \n  max_depth = nothing, \n  min_samples_leaf = 1, \n  min_purity_increase = -Inf, \n  max_purity_at_leaf = Inf, \n  max_modal_depth = nothing, \n  relations = nothing, \n  features = nothing, \n  conditions = nothing, \n  featvaltype = Float64, \n  initconditions = nothing, \n  downsize = SoleData.var\"#downsize#542\"(), \n  force_i_variables = true, \n  fixcallablenans = false, \n  print_progress = false, \n  rng = Random.TaskLocalRNG(), \n  display_depth = nothing, \n  min_samples_split = nothing, \n  n_subfeatures = ModalDecisionTrees.MLJInterface.sqrt_f, \n  post_prune = false, \n  merge_purity_threshold = nothing, \n  feature_importance = :split)\n\nModalAdaBoost(\n  max_depth = 1, \n  min_samples_leaf = 4, \n  min_purity_increase = 0.002, \n  max_purity_at_leaf = Inf, \n  max_modal_depth = nothing, \n  relations = :IA7, \n  features = nothing, \n  conditions = nothing, \n  featvaltype = Float64, \n  initconditions = nothing, \n  downsize = SoleData.var\"#downsize#541\"(), \n  force_i_variables = true, \n  fixcallablenans = true, \n  print_progress = false, \n  display_depth = nothing, \n  min_samples_split = nothing, \n  n_subfeatures = identity, \n  post_prune = false, \n  merge_purity_threshold = nothing, \n  n_iter = 10, \n  feature_importance = :split, \n  rng = Random.TaskLocalRNG())\n\nFrom package Chen, T., & Guestrin, C. (2016). XGBoost.jl\n\nXGBoostClassifier(\n  test = 1, \n  num_round = 100, \n  booster = \"gbtree\", \n  disable_default_eval_metric = 0, \n  eta = 0.3, \n  num_parallel_tree = 1, \n  gamma = 0.0, \n  max_depth = 6, \n  min_child_weight = 1.0, \n  max_delta_step = 0.0, \n  subsample = 1.0, \n  colsample_bytree = 1.0, \n  colsample_bylevel = 1.0, \n  colsample_bynode = 1.0, \n  lambda = 1.0, \n  alpha = 0.0, \n  tree_method = \"auto\", \n  sketch_eps = 0.03, \n  scale_pos_weight = 1.0, \n  updater = nothing, \n  refresh_leaf = 1, \n  process_type = \"default\", \n  grow_policy = \"depthwise\", \n  max_leaves = 0, \n  max_bin = 256, \n  predictor = \"cpu_predictor\", \n  sample_type = \"uniform\", \n  normalize_type = \"tree\", \n  rate_drop = 0.0, \n  one_drop = 0, \n  skip_drop = 0.0, \n  feature_selector = \"cyclic\", \n  top_k = 0, \n  tweedie_variance_power = 1.5, \n  objective = \"automatic\", \n  base_score = 0.5, \n  early_stopping_rounds = 0, \n  watchlist = nothing, \n  nthread = 1, \n  importance_type = \"gain\", \n  seed = nothing, \n  validate_parameters = false, \n  eval_metric = String[], \n  monotone_constraints = nothing)\n\nXGBoostRegressor(\n  test = 1, \n  num_round = 100, \n  booster = \"gbtree\", \n  disable_default_eval_metric = 0, \n  eta = 0.3, \n  num_parallel_tree = 1, \n  gamma = 0.0, \n  max_depth = 6, \n  min_child_weight = 1.0, \n  max_delta_step = 0.0, \n  subsample = 1.0, \n  colsample_bytree = 1.0, \n  colsample_bylevel = 1.0, \n  colsample_bynode = 1.0, \n  lambda = 1.0, \n  alpha = 0.0, \n  tree_method = \"auto\", \n  sketch_eps = 0.03, \n  scale_pos_weight = 1.0, \n  updater = nothing, \n  refresh_leaf = 1, \n  process_type = \"default\", \n  grow_policy = \"depthwise\", \n  max_leaves = 0, \n  max_bin = 256, \n  predictor = \"cpu_predictor\", \n  sample_type = \"uniform\", \n  normalize_type = \"tree\", \n  rate_drop = 0.0, \n  one_drop = 0, \n  skip_drop = 0.0, \n  feature_selector = \"cyclic\", \n  top_k = 0, \n  tweedie_variance_power = 1.5, \n  objective = \"reg:squarederror\", \n  base_score = 0.5, \n  early_stopping_rounds = 0, \n  watchlist = nothing, \n  nthread = 1, \n  importance_type = \"gain\", \n  seed = nothing, \n  validate_parameters = false, \n  eval_metric = String[], \n  monotone_constraints = nothing)\n\nEach model is fully parameterizable, see the original package reference documentation.\n\nData resampling\n\nresampling::ResamplingStrategy=Holdout(shuffle=true): Cross-validation strategy\nvalid_ratio::Real=0.0: Validation set proportion\nrng::AbstractRNG=TaskLocalRNG(): Random number generator for reproducibility\n\nResampling strategies are taken from the package MLJ. See official documentation here. Available strategies:\n\nHoldout(; fraction_train=0.7, shuffle=true, rng=TaskLocalRNG())\n\nCV(; nfolds=6,  shuffle=true, rng=TaskLocalRNG())\n\nStratifiedCV(; nfolds=6, shuffle=true, rng=TaskLocalRNG())\n\nTimeSeriesCV(; nfolds=4)\n\nvalid_ratio is used with XGBoost early stop technique. rng can be setted externally (via seed, using internal Xoshiro algo) for convenience.\n\nBalancing\n\nBalancing strategies are taken from the package Imbalance. See official documentation here. Available strategies:\n\nBorderlineSMOTE1(\n  m = 5, \n  k = 5, \n  ratios = 1.0, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true, \n  verbosity = 1)\n\nClusterUndersampler(\n  mode = \"nearest\", \n  ratios = 1.0, \n  maxiter = 100, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nENNUndersampler(\n  k = 5, \n  keep_condition = \"mode\", \n  min_ratios = 1.0, \n  force_min_ratios = false, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nROSE(\n  s = 1.0, \n  ratios = 1.0, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nRandomOversampler(\n  ratios = 1.0, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nRandomUndersampler(\n  ratios = 1.0, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nRandomWalkOversampler(\n  ratios = 1.0, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nSMOTE(\n  k = 5, \n  ratios = 1.0, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nSMOTEN(\n  k = 5, \n  ratios = 1.0, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nSMOTENC(\n  k = 5, \n  ratios = 1.0, \n  knn_tree = \"Brute\", \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nTomekUndersampler(\n  min_ratios = 1.0, \n  force_min_ratios = false, \n  rng = Random.TaskLocalRNG(), \n  try_preserve_type = true)\n\nTuning\n\ntuning::MaybeTuning=nothing: Hyperparameter tuning configuration, requires range vectors, i.e:\n\nrange = SoleXplorer.range(:min_purity_increase; lower=0.1, upper=1.0, scale=:log)\n\nTuning strategies are adapted from the package MLJ and package MLJParticleSwarmOptimization.\n\nAvailable strategies:\n\nGridTuning(\n  goal = nothing, \n  resolution = 10, \n  shuffle = true, \n  rng = Random.TaskLocalRNG(),\n  range = range,\n  resampling = nothing\n  measure = nothing\n  repeats = 1)\n\nRandomTuning(\n  bounded = Distributions.Uniform, \n  positive_unbounded = Distributions.Gamma, \n  other = Distributions.Normal, \n  rng = Random.TaskLocalRNG(),\n  range = range,\n  resampling = nothing\n  measure = nothing\n  repeats = 1)\n\nCubeTuning(\n  gens = 1, \n  popsize = 100, \n  ntour = 2, \n  ptour = 0.8, \n  interSampleWeight = 1.0, \n  ae_power = 2, \n  periodic_ae = false, \n  rng = Random.TaskLocalRNG(),\n  range = range,\n  resampling = nothing\n  measure = nothing\n  repeats = 1\n\nParticleTuning(\n  n_particles = 3, \n  w = 1.0, \n  c1 = 2.0, \n  c2 = 2.0, \n  prob_shift = 0.25, \n  rng = Random.TaskLocalRNG(),\n  range = range,\n  resampling = nothing\n  measure = nothing\n  repeats = 1)\n\nAdaptiveTuning(\n  n_particles = 3, \n  c1 = 2.0, \n  c2 = 2.0, \n  prob_shift = 0.25, \n  rng = Random.TaskLocalRNG(),\n  range = range,\n  resampling = nothing\n  measure = nothing\n  repeats = 1) \n\nMultidimensional Data Processing\n\nThese parameters are needed only if a time series dataset is used. With these parameters we can tweak size reduction, in case of modal analysis or aggregation strategy, in case of further propositional analysis. Parameters are the same, SoleXplorer will take care of automatically set the case, depending on the model choose.\n\nwin::WinFunction=AdaptiveWindow(nwindows=3, relative_overlap=0.1): Windowing function\n\nAvailable windows strategies: MovingWindow, WholeWindow, SplitWindow, AdaptiveWindow.\n\nfeatures::Tuple{Vararg{Base.Callable}}=(maximum, minimum): Feature extraction functions\n\nNote that beyond standard reduction functions (e.g., maximum, minimum, mean, mode), Catch22 time-series features are also available.\n\nmodalreduce::Base.Callable=mean: Reduction function for modal algorithms\n\nReturns\n\nPropositionalDataSet{M}: For standard ML algorithms with tabular data\nModalDataSet{M}: For modal logic algorithms with structured data\n\nExamples:\n\nusing SoleXplorer\nusing MLJ\nusing DataFrames, Random\nconst SX = SoleXplorer\n\nXc, yc = @load_iris\nXc = DataFrame(Xc)\n\nXr, yr = @load_boston\nXr = DataFrame(Xr)\n\nnatopsloader = NatopsLoader()\nXts, yts = SX.load(natopsloader)\n\n# basic setup\ndsc = setup_dataset(Xc, yc)\n\n# model type specification\ndsc = setup_dataset(\n    Xc, yc;\n    model=AdaBoostStumpClassifier()\n)\n\n# resampling\ndsc = setup_dataset(\n    Xc, yc;\n    resampling=CV(nfolds=10),\n)\n\ndsc = setup_dataset(\n    Xc, yc;\n    resampling=CV(nfolds=10, shuffle=true),\n    seed=1\n)\n\n# tuning\nrange = SX.range(:min_purity_increase; lower=0.001, upper=1.0, scale=:log)\ndsc = setup_dataset(\n    Xc, yc;\n    model=ModalDecisionTree(),\n    resampling=CV(nfolds=5, shuffle=true),\n    seed=1,\n    tuning=GridTuning(resolution=10, resampling=CV(nfolds=3), range=range, measure=accuracy, repeats=2)\n)\n\n# time-series\ndts = setup_dataset(\n    Xts, yts;\n    model=ModalRandomForest(),\n    resampling=Holdout(fraction_train=0.7, shuffle=true),\n    seed=1,\n    win=AdaptiveWindow(nwindows=3, relative_overlap=0.3),\n    features=(minimum, maximum),\n    modalreduce=mode\n)\n\nSee also: DataSet, PropositionalDataSet, ModalDataSet, symbolic_analysis\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.setup_dataset-Tuple{DataFrames.AbstractDataFrame, Symbol}","page":"Setup Dataset","title":"SoleXplorer.setup_dataset","text":"setup_dataset(X::AbstractDataFrame, y::Symbol; kwargs...)::AbstractDataSet\n\nConvenience method when target variable is a column in the feature DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#dataset","page":"Setup Dataset","title":"Dataset","text":"","category":"section"},{"location":"dataset/#SoleXplorer.AbstractDataSet","page":"Setup Dataset","title":"SoleXplorer.AbstractDataSet","text":"AbstractDataSet\n\nAbstract supertype for all dataset structures in SoleXplorer.\n\nConcrete subtypes include:\n\nPropositionalDataSet: for standard ML algorithms with aggregated features\nModalDataSet: for modal logic algorithms with temporal structure preservation\n\nSee also: setup_dataset\n\n\n\n\n\n","category":"type"},{"location":"dataset/#SoleXplorer.AbstractSoleModel","page":"Setup Dataset","title":"SoleXplorer.AbstractSoleModel","text":"AbstractSoleModel\n\nBase abstract type for all symbolic model containers in SoleXplorer.\n\n\n\n\n\n","category":"type"},{"location":"dataset/#SoleXplorer.PropositionalDataSet","page":"Setup Dataset","title":"SoleXplorer.PropositionalDataSet","text":"PropositionalDataSet{M} <: AbstractDataSet\n\nDataset wrapper for standard machine learning algorithms that work with tabular/propositional data.\n\nThis dataset type encapsulates an MLJ machine along with partitioning information and optional aggregation metadata. It is used when working with traditional ML models that require flattened feature representations, typically created by aggregating multidimensional data.\n\nFields\n\nmach::MLJ.Machine: MLJ machine containing the model, training data, and cache\npidxs::Vector{PartitionIdxs}: Partition indices for train/test splits across folds\npinfo::PartitionInfo: Metadata about the partitioning strategy used\nainfo::MaybeAggregationInfo: Optional aggregation information for multidimensional data\n\nType Parameter\n\nM: The type of the MLJ model contained in the machine\n\nSee also: ModalDataSet, setup_dataset, AbstractDataSet\n\n\n\n\n\n","category":"type"},{"location":"dataset/#SoleXplorer.ModalDataSet","page":"Setup Dataset","title":"SoleXplorer.ModalDataSet","text":"ModalDataSet{M} <: AbstractDataSet\n\nDataset wrapper for modal logic algorithms that preserve temporal/structural relationships.\n\nThis dataset type is designed for modal learning algorithms that can work directly with multidimensional time series or structured data without requiring feature aggregation. It maintains treatment information that describes how the original data structure is preserved.\n\nFields\n\nmach::MLJ.Machine: MLJ machine containing the modal model, training data, and cache\npidxs::Vector{PartitionIdxs}: Partition indices for train/test splits across folds\npinfo::PartitionInfo: Metadata about the partitioning strategy used  \ntinfo::TreatmentInfo: Treatment information describing data structure preservation\n\nType Parameter\n\nM: The type of the modal MLJ model contained in the machine\n\nSee also: PropositionalDataSet, setup_dataset, AbstractDataSet\n\n\n\n\n\n","category":"type"},{"location":"dataset/#SoleXplorer.DataSet","page":"Setup Dataset","title":"SoleXplorer.DataSet","text":"DataSet(mach, pidxs, pinfo; tinfo=nothing) -> AbstractDataSet\n\nConstructor function that creates the appropriate dataset type based on treatment information.\n\nThis function serves as a smart constructor that automatically determines whether to create a PropositionalDataSet or ModalDataSet based on the provided treatment information and the type of treatment specified.\n\nArguments\n\nmach::MLJ.Machine{M}: MLJ machine containing model and data\npidxs::Vector{PartitionIdxs}: Partition indices for cross-validation folds\npinfo::PartitionInfo: Information about the partitioning strategy\ntinfo::MaybeTreatInfo=nothing: Optional treatment information for multidimensional data\n\nReturns\n\nPropositionalDataSet{M}: When tinfo is nothing or treatment is not :reducesize\nModalDataSet{M}: When tinfo specifies :reducesize treatment\n\nDecision Logic\n\nNo treatment info (tinfo = nothing): Creates PropositionalDataSet with no aggregation info\nReduce size treatment (get_treatment(tinfo) == :reducesize): Creates ModalDataSet preserving structure\nOther treatments (e.g., :aggregate): Creates PropositionalDataSet with aggregation info converted from treatment\n\nType Parameter\n\nM <: MLJ.Model: The type of the model in the MLJ machine\n\nSee also: PropositionalDataSet, ModalDataSet, AbstractDataSet\n\n\n\n\n\n","category":"function"},{"location":"dataset/#SoleXplorer.get_X-Tuple{AbstractDataSet}","page":"Setup Dataset","title":"SoleXplorer.get_X","text":"get_X(ds::AbstractDataSet) -> DataFrame\n\nExtract feature DataFrame from dataset's MLJ machine.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.get_X-Tuple{AbstractDataSet, Symbol}","page":"Setup Dataset","title":"SoleXplorer.get_X","text":"get_X(ds::AbstractDataSet, part::Symbol) -> Vector{<:AbstractDataFrame}\n\nExtract feature DataFrames for a specific partition (e.g., :train, :test or :valid) across all folds.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.get_y-Tuple{AbstractDataSet}","page":"Setup Dataset","title":"SoleXplorer.get_y","text":"get_y(ds::AbstractDataSet) -> Vector\n\nExtract target vector from dataset's MLJ machine.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.get_y-Tuple{AbstractDataSet, Symbol}","page":"Setup Dataset","title":"SoleXplorer.get_y","text":"get_y(ds::AbstractDataSet, part::Symbol) -> Vector{<:AbstractVector}\n\nExtract target values for a specific partition (e.g., :train, :test or :valid) across all folds.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.get_mach-Tuple{AbstractDataSet}","page":"Setup Dataset","title":"SoleXplorer.get_mach","text":"get_mach(ds::AbstractDataSet)::Machine\n\nExtract the MLJ machine from the dataset.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.get_mach_model-Tuple{AbstractDataSet}","page":"Setup Dataset","title":"SoleXplorer.get_mach_model","text":"get_mach_model(ds::AbstractDataSet)::MLJ.Model\n\nExtract the model from the dataset's MLJ machine.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.get_logiset-Tuple{ModalDataSet}","page":"Setup Dataset","title":"SoleXplorer.get_logiset","text":"get_logiset(ds::ModalDataSet)::SupportedLogiset\n\nExtract the logiset (if present) from the dataset's MLJ machine.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#utilities","page":"Setup Dataset","title":"Utilities","text":"","category":"section"},{"location":"dataset/#SoleXplorer.code_dataset-Tuple{DataFrames.AbstractDataFrame}","page":"Setup Dataset","title":"SoleXplorer.code_dataset","text":"code_dataset(X::AbstractDataFrame)\n\nIn-place encoding of non-numeric columns in a DataFrame to numeric codes.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.code_dataset-Tuple{AbstractVector}","page":"Setup Dataset","title":"SoleXplorer.code_dataset","text":"code_dataset(y::AbstractVector)\n\nIn-place encoding of non-numeric target vector to numeric codes.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#SoleXplorer.code_dataset-Tuple{DataFrames.AbstractDataFrame, AbstractVector}","page":"Setup Dataset","title":"SoleXplorer.code_dataset","text":"code_dataset(X::AbstractDataFrame, y::AbstractVector)\n\nConvenience method to encode both features and target simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#train-test","page":"Setup Dataset","title":"Train and Test Dataset","text":"","category":"section"},{"location":"dataset/#SoleXplorer.train_test-Tuple{AbstractDataSet}","page":"Setup Dataset","title":"SoleXplorer.train_test","text":"train_test(ds::AbstractDataSet) -> SoleModel\n\nDirect training interface for pre-configured datasets. No additional parameters needed.\n\nSee also: symbolic_analysis, setup_dataset\n\n\n\n\n\n","category":"method"},{"location":"tuning/#tuning","page":"Tuning","title":"Tuning","text":"","category":"section"},{"location":"tuning/","page":"Tuning","title":"Tuning","text":"SoleXplorer uses the following tuning strategies adapted from package MLJ: GridTuning, RandomTuning, CubeTuning, ParticleTuning and AdaptiveTuning.","category":"page"},{"location":"tuning/","page":"Tuning","title":"Tuning","text":"strategy_type::Type{<:Any}(;\n    range::RangeSpec,\n    MLJ.ResamplingStrategy=Holdout(fraction_train=0.7, shuffle=true),\n    measure::MaybeMeasure=nothing,\n    repeats::Int64=1,\n    strategy_kwargs...\n) -> Tuning","category":"page"},{"location":"tuning/#Arguments","page":"Tuning","title":"Arguments","text":"","category":"section"},{"location":"tuning/","page":"Tuning","title":"Tuning","text":"strategy_type: Type of optimization strategy to instantiate\nrange: Parameter ranges to explore\nresampling: Cross-validation for hyperparameter evaluation\nmeasure: Performance metric for optimization  \nrepeats: Number of optimization runs\nkwargs...: Strategy-specific parameters","category":"page"},{"location":"tuning/#tuning-strategies","page":"Tuning","title":"Tuning Strategies","text":"","category":"section"},{"location":"tuning/#SoleXplorer.GridTuning","page":"Tuning","title":"SoleXplorer.GridTuning","text":"GridTuning(; kwargs...) -> Tuning\n\nCreate a grid search tuning configuration. Parameters reference: MLJTuning.Grid\n\n\n\n\n\n","category":"function"},{"location":"tuning/#SoleXplorer.RandomTuning","page":"Tuning","title":"SoleXplorer.RandomTuning","text":"RandomTuning(; kwargs...) -> Tuning\n\nCreate a random search tuning configuration. Parameters reference: MLJTuning.RandomSearch\n\n\n\n\n\n","category":"function"},{"location":"tuning/#SoleXplorer.CubeTuning","page":"Tuning","title":"SoleXplorer.CubeTuning","text":"CubeTuning(; kwargs...) -> Tuning\n\nCreate a Latin hypercube sampling tuning configuration. Parameters reference: MLJTuning.LatinHypercube\n\n\n\n\n\n","category":"function"},{"location":"tuning/#SoleXplorer.ParticleTuning","page":"Tuning","title":"SoleXplorer.ParticleTuning","text":"ParticleTuning(; kwargs...) -> Tuning\n\nCreate a particle swarm optimization tuning configuration. Parameters reference: MLJParticleSwarmOptimization\n\n\n\n\n\n","category":"function"},{"location":"tuning/#SoleXplorer.AdaptiveTuning","page":"Tuning","title":"SoleXplorer.AdaptiveTuning","text":"AdaptiveTuning(; kwargs...) -> Tuning\n\nCreate an adaptive particle swarm optimization tuning configuration. Parameters reference: MLJParticleSwarmOptimization\n\n\n\n\n\n","category":"function"},{"location":"tuning/#range","page":"Tuning","title":"Tuning Range","text":"","category":"section"},{"location":"tuning/#Base.range","page":"Tuning","title":"Base.range","text":"range(field::Union{Symbol,Expr}; kwargs...)\n\nWrapper for MLJ.range in hyperparameter tuning contexts.\n\nArguments\n\nfield::Union{Symbol,Expr}: Model field to tune\nkwargs...: Range specification arguments\n\nReturns\n\nTuple of (field, kwargs) for later processing by tuning setup\n\nThis function provides a more convenient syntax for specifying hyperparameter ranges that will be converted to proper MLJ ranges once the model is available.\n\n\n\n\n\n","category":"function"},{"location":"serialize/#serialize","page":"Serialization","title":"Serialization","text":"","category":"section"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"SoleXplorer provides serialization functionality using the JLD2 format. It enables saving and loading of datasets, models, and analysis results with automatic file naming conventions and path management.","category":"page"},{"location":"serialize/#Supported-Types","page":"Serialization","title":"Supported Types","text":"","category":"section"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"All serialization functions work with types that implement the Saveable union:","category":"page"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"AbstractDataSet: Dataset configurations and ML pipelines\nAbstractSoleModel: Trained symbolic models  \nAbstractModelSet: Complete analysis results with multiple models","category":"page"},{"location":"serialize/#File-Format","page":"Serialization","title":"File Format","text":"","category":"section"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"All files are saved in JLD2 format with automatic .jld2 extension handling.","category":"page"},{"location":"serialize/#Naming-Convention","page":"Serialization","title":"Naming Convention","text":"","category":"section"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"Files are automatically prefixed based on content type:","category":"page"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"Datasets: soleds_<name>.jld2\nModels: solemodel_<name>.jld2 \nAnalysis: soleanalysis_<name>.jld2","category":"page"},{"location":"serialize/#SoleXplorer.solesave","page":"Serialization","title":"SoleXplorer.solesave","text":"solesave(sole::Saveable; path::AbstractString, name::AbstractString)\n\nThis function handles the core serialization logic including file path construction, existence checking, and JLD2 serialization.\n\nArguments\n\nsole::Saveable: Object to serialize\npath::AbstractString: Directory path for saving (defaults to current directory)\nname::AbstractString: Base filename (automatically gets .jld2 extension)\n\nSee also: soleload\n\n\n\n\n\n","category":"function"},{"location":"serialize/#SoleXplorer.soleload","page":"Serialization","title":"SoleXplorer.soleload","text":"soleload(path::AbstractString, name::AbstractString) -> Saveable\n\nLoad a previously saved SoleXplorer object from disk.\n\nRestores datasets, models, or analysis results from JLD2 files created by solesave. The returned object type depends on what was originally saved.\n\nArguments\n\npath::AbstractString: Directory path containing the file\nname::AbstractString: Filename (with or without .jld2 extension)\n\nFile Extension\n\nAutomatically adds .jld2 extension if not provided in name.\n\nSee also: solesave\n\n\n\n\n\n","category":"function"},{"location":"serialize/#Examples","page":"Serialization","title":"Examples","text":"","category":"section"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"using Test\nusing SoleXplorer\nusing MLJ\nusing DataFrames, Random\nconst SX = SoleXplorer\n\nXc, yc = @load_iris\nXc = DataFrame(Xc)\n\npath = @__DIR__\n\n# save dataset setup\nr1 = SX.range(:(oversampler.k), lower=3, upper=10)\nr2 = SX.range(:(undersampler.min_ratios), lower=0.1, upper=0.9)\n\ndsc = setup_dataset(\n    Xc, yc;\n    model=DecisionTreeClassifier(max_depth=3),\n    resampling=StratifiedCV(nfolds=5, shuffle=true),\n    seed=11,\n    balancing=(\n        oversampler=SMOTENC(k=5, ratios=1.0),\n        undersampler=TomekUndersampler(min_ratios=0.5)),\n    tuning=GridTuning(goal=4, range=(r1,r2))\n)\nsolesave(dsc; path, name=\"test1\")\n\nsolemc = train_test(dsc)\nsolesave(solemc; path, name=\"test1.jld2\")\n\nmodelc = symbolic_analysis(\n    dsc, solemc,\n    extractor=LumenRuleExtractor(minimization_scheme=:mitespresso),\n    measures=(accuracy, log_loss, kappa)\n)\nsolesave(modelc; path, name=\"test1\")\n\n# load dataset setup\nds_name        = \"soleds_test1\"\nsolemodel_name = \"solemodel_test1.jld2\"\nanalysis_name  = \"soleanalysis_test1\"\n\ndsc_loaded      = soleload(path, ds_name)\nmodel_loaded    = soleload(path, solemodel_name)\nanalysis_loaded = soleload(path, analysis_name)","category":"page"},{"location":"serialize/","page":"Serialization","title":"Serialization","text":"See also: solesave, soleload \"\"\"","category":"page"},{"location":"symbolic_analysis/#symbolic-analysis","page":"Symbolic Analysis","title":"Symbolic analysis","text":"","category":"section"},{"location":"symbolic_analysis/","page":"Symbolic Analysis","title":"Symbolic Analysis","text":"This is the entry point of SoleXplorer: this function can be used standalone, for finalize an already trained model, or to update already analyzed results.","category":"page"},{"location":"symbolic_analysis/#SoleXplorer.symbolic_analysis-Tuple{DataFrames.AbstractDataFrame, AbstractVector, Union{Nothing, AbstractVector}}","page":"Symbolic Analysis","title":"SoleXplorer.symbolic_analysis","text":"symbolic_analysis(\n    X::AbstractDataFrame,\n    y::AbstractVector,\n    w::MaybeVector=nothing;\n    extractor::MaybeRuleExtractor=nothing,\n    association::Union{Nothing,AbstractAssociationRuleExtractor}=nothing,\n    measures::Tuple{Vararg{FussyMeasure}}=(),\n    kwargs...\n) -> ModelSet\n\nComplete end-to-end symbolic model analysis workflow.\n\nThis is the main entry point for symbolic analysis. It performs the complete workflow:\n\nDataset Setup: Configures cross-validation and time series preprocessing.\nModel Configuration: Sets up the MLJ machine.\nModel Training: Trains symbolic models on each CV fold.\nRule Extraction: Extracts interpretable rules from trained models.\nAssociation Mining: Discovers feature relationships and patterns.\nEvaluation: Computes comprehensive performance metrics.\n\nArguments\n\nX::AbstractDataFrame: Feature matrix with observations as rows\ny::AbstractVector: Target variable (labels for classification)\nw::MaybeVector: Sample weights (optional)\n\nAnalysis Options\n\nextractor: Rule extraction method: See SolePostHoc\nassociation: Association rule mining: See ModalAssociationRules\nmeasures: Performance measures tuple:\n(accuracy, auc, f1_score): Custom measures\n(): Use default measures for task type\n\nDataset & Training Options (kwargs)\n\nSee setup_dataset\n\nExamples\n\n# Basic analysis with default settings\nmodelset = symbolic_analysis(X, y)\n\n# Full analysis example\nrange = SoleXplorer.range(:min_purity_increase; lower=0.001, upper=1.0, scale=:log)\nmodelset = symbolic_analysis(X, y;\n    model=RandomForestClassifier(),\n    resampling=CV(nfolds=5, shuffle=true),\n    seed=1,\n    tuning=GridTuning(resolution=10, resampling=CV(nfolds=3), range=range, measure=accuracy, repeats=2),\n    extractor=InTreesRuleExtractor(),\n    measures=(accuracy, log_loss, confusion_matrix, kappa)   \n)\n\n# Time series analysis example\nmodelset = symbolic_analysis(X, y;\n    model=ModalRandomForest(),\n    resampling=Holdout(fraction_train=0.7, shuffle=true),\n    seed=1,\n    features=(minimum, maximum),\n    measures=(log_loss, accuracy, confusion_matrix, kappa)\n)\n\n# Access modelset\nsetup = dsetup(modelset)\nmodels = solemodels(modelset)\nrules = rules(modelset)  \nassociations = associations(modelset)\nperformance = performance(modelset)\n\nSee also: ModelSet, setup_dataset, train_test\n\n\n\n\n\nsymbolic_analysis(X::Any, args...; kwargs...) -> ModelSet\n\nConvenience method that converts input data to DataFrame format.\n\nSee also: symbolic_analysis\n\n\n\n\n\n","category":"method"},{"location":"symbolic_analysis/#SoleXplorer.symbolic_analysis-Tuple{AbstractDataSet, SoleXplorer.SoleModel}","page":"Symbolic Analysis","title":"SoleXplorer.symbolic_analysis","text":"symbolic_analysis(ds::AbstractDataSet, solem::SoleModel; kwargs...) -> ModelSet\n\nPerform complete symbolic analysis on pre-trained models.\n\nArguments\n\nds::AbstractDataSet: Dataset used for training the models.\nsolem::SoleModel: Trained sole symbolic models.\nkwargs...: Analysis options (extractor, association, measures).\n\nExamples\n\n# analyze pre-trained models\nds = setup_dataset(\n    X, y;\n    model=DecisionTreeClassifier(),\n    resampling=CV(nfolds=5, shuffle=true)\n)\nsolem = train_test(ds)\nresults = symbolic_analysis(\n    ds, solem; \n    extractor=Lumen(),\n    measures=(accuracy, kappa)\n)\n\nSee also: symbolic_analysis!, setup_dataset, train_test\n\n\n\n\n\n","category":"method"},{"location":"symbolic_analysis/#SoleXplorer.symbolic_analysis!-Tuple{ModelSet}","page":"Symbolic Analysis","title":"SoleXplorer.symbolic_analysis!","text":"symbolic_analysis!(modelset::ModelSet; kwargs...)\n\nPerform additional analysis on an existing ModelSet.\n\nIn-place version that adds or updates analysis components (rules, associations, measures) on an existing ModelSet.\n\nExamples\n\n# initial analysis\nmodelset = symbolic_analysis(X, y)\n\n# add rule extraction later\nsymbolic_analysis!(modelset; extractor=Lumen())\n\n# add association mining later\nsymbolic_analysis!(modelset; association=Apriori())\n\nSee also: symbolic_analysis, ModelSet\n\n\n\n\n\n","category":"method"},{"location":"symbolic_analysis/#ModelSet","page":"Symbolic Analysis","title":"ModelSet","text":"","category":"section"},{"location":"symbolic_analysis/#SoleXplorer.AbstractModelSet","page":"Symbolic Analysis","title":"SoleXplorer.AbstractModelSet","text":"AbstractModelSet\n\nAbstract type for containers that hold symbolic model analysis results.\n\nConcrete Implementations\n\nModelSet: The primary implementation containing complete analysis results\n\nSee also: symbolic_analysis\n\n\n\n\n\n","category":"type"},{"location":"symbolic_analysis/#SoleXplorer.ModelSet","page":"Symbolic Analysis","title":"SoleXplorer.ModelSet","text":"ModelSet{S} <: AbstractModelSet\n\nWrapper for complete symbolic model analysis results.\n\nThis structure holds all components of a symbolic analysis workflow including the dataset configuration, sole trained models, extracted rules, association rules, and performance measures.\n\nType Parameters\n\nS: The sole model type (e.g., DecisionTreeClassifier)\n\nFields\n\nds::AbstractDataSet: Dataset configuration with cross-validation setup,  plus all settings needed by modal analysis.\nsole::Vector{AbstractModel}: Vector of trained symbolic models (one per CV fold)\n\nOptional\n\nrules::MaybeRules: Extracted rules\nassociations::MaybeAssociations: Association rules between features\nmeasures::MaybeMeasures: Performance evaluation measures\n\nAccessing Components\n\ndsetup: Extract dataset configuration\nsolemodels: Extract trained models\nrules: Extract decision rules\nassociations: Extract association rules\n\nSee also: symbolic_analysis\n\n\n\n\n\n","category":"type"},{"location":"symbolic_analysis/#SoleXplorer.dsetup-Tuple{ModelSet}","page":"Symbolic Analysis","title":"SoleXplorer.dsetup","text":"dsetup(m::ModelSet) -> AbstractDataSet\n\nReturns the dataset configuration from a ModelSet.\n\nSee also: ModelSet, symbolic_analysis\n\n\n\n\n\n","category":"method"},{"location":"symbolic_analysis/#SoleXplorer.solemodels-Tuple{ModelSet}","page":"Symbolic Analysis","title":"SoleXplorer.solemodels","text":"solemodels(m::ModelSet) -> Vector{AbstractModel}\n\nReturns the trained sole symbolic models from a ModelSet.\n\nSee also: ModelSet, symbolic_analysis\n\n\n\n\n\n","category":"method"},{"location":"symbolic_analysis/#SoleXplorer.rules-Tuple{ModelSet}","page":"Symbolic Analysis","title":"SoleXplorer.rules","text":"rules(m::ModelSet) -> MaybeRules\n\nReturns the rules extracted from a ModelSet. Returns nothing if rule extraction isn't yet performed.\n\nSee also: ModelSet, symbolic_analysis\n\n\n\n\n\n","category":"method"},{"location":"symbolic_analysis/#SoleXplorer.associations-Tuple{ModelSet}","page":"Symbolic Analysis","title":"SoleXplorer.associations","text":"associations(m::ModelSet) -> MaybeAssociaRules\n\nReturns the association rules extracted from a ModelSet. Returns nothing if association rules isn't yet performed.\n\nSee also: ModelSet, symbolic_analysis\n\n\n\n\n\n","category":"method"},{"location":"symbolic_analysis/#SoleXplorer.performance-Tuple{ModelSet}","page":"Symbolic Analysis","title":"SoleXplorer.performance","text":"performance(m::ModelSet) -> MaybeMeasures\n\nExtract the performance evaluation measures from a ModelSet.\n\nSee also: ModelSet, symbolic_analysis\n\n\n\n\n\n","category":"method"},{"location":"treatement/#treatement","page":"Multi Dimensional Treatement","title":"Treatement","text":"","category":"section"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"With multidimensional datasets there are two possible types of work:","category":"page"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"Use of Propositional algorithms (DecisionTree, XGBoost):\nApplies windowing to divide time series into segments\nExtracts scalar features (max, min, mean, etc.) from each window\nReturns a standard tabular DataFrame\nUse of Modal algorithms (ModalDecisionTree):\nCreates windowed time series preserving temporal structure\nApplies reduction functions to manage dimensionality","category":"page"},{"location":"treatement/#SoleXplorer.treatment-Tuple{DataFrames.AbstractDataFrame, Symbol}","page":"Multi Dimensional Treatement","title":"SoleXplorer.treatment","text":"treatment(X::AbstractDataFrame; treat::Symbol, win::WinFunction, \n         features::Tuple, modalreduce::Base.Callable) -> (DataFrame, TreatmentInfo)\n\nTransform multidimensional dataset based on specified treatment strategy.\n\nArguments\n\nX::AbstractDataFrame: Input dataset with time series in each cell\ntreat::Symbol: Treatment type - :aggregate, :reducesize or :none\nwin::WinFunction: Windowing strategy (default: AdaptiveWindow(nwindows=3, relative_overlap=0.1))\nfeatures::Tuple: Feature extraction functions (default: (maximum, minimum))\nmodalreduce::Base.Callable: Reduction function for modal treatments (default: mean)\n\nTreatment Types\n\n:aggregate (for Propositional Algorithms)\n\nExtracts scalar features from time series windows:\n\nSingle window: Applies features to entire time series\nMultiple windows: Creates feature columns per window (e.g., \"max(col1)w1\")\n\n:reducesize (for Modal Algorithms)\n\nPreserves temporal structure while reducing dimensionality:\n\nApplies reduction function to each window\nMaintains Vector{Float64} format for modal logic compatibility\n\n:none (for particular cases)\n\nReturns the dataset\n\n\n\n\n\n","category":"method"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"Windowing strategies availables for reduce/aggregation time-series datasets.","category":"page"},{"location":"treatement/#SoleXplorer.MovingWindow","page":"Multi Dimensional Treatement","title":"SoleXplorer.MovingWindow","text":"MovingWindow(; window_size::Int, window_step::Int) -> WinFunction\n\nCreate a moving window that slides across the time series.\n\nParameters\n\nwindow_size: Number of time points in each window\nwindow_step: Step size between consecutive windows\n\nExample\n\nwin = MovingWindow(window_size=10, window_step=5)\nintervals = win(100)  # For 100-point time series\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.WholeWindow","page":"Multi Dimensional Treatement","title":"SoleXplorer.WholeWindow","text":"WholeWindow() -> WinFunction\n\nCreate a single window encompassing the entire time series. Useful for global feature extraction without temporal partitioning.\n\nExample\n\nwin = WholeWindow()\nintervals = win(100)  # Returns [1:100]\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.SplitWindow","page":"Multi Dimensional Treatement","title":"SoleXplorer.SplitWindow","text":"SplitWindow(; nwindows::Int) -> WinFunction\n\nDivide the time series into equal non-overlapping segments.\n\nParameters\n\nnwindows: Number of equal-sized windows to create\n\nExample\n\nwin = SplitWindow(nwindows=4)\nintervals = win(100)  # Four 25-point windows\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.AdaptiveWindow","page":"Multi Dimensional Treatement","title":"SoleXplorer.AdaptiveWindow","text":"AdaptiveWindow(; nwindows::Int, relative_overlap::AbstractFloat) -> WinFunction\n\nCreate overlapping windows with adaptive sizing based on series length.\n\nParameters\n\nnwindows: Target number of windows\nrelative_overlap: Fraction of overlap between adjacent windows (0.0-1.0)\n\nExample\n\nwin = AdaptiveWindow(nwindows=3, relative_overlap=0.1)\nintervals = win(100)  # Three adaptive windows with 10% overlap\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.AbstractWinFunction","page":"Multi Dimensional Treatement","title":"SoleXplorer.AbstractWinFunction","text":"AbstractWinFunction\n\nBase type for windowing function implementations.\n\n\n\n\n\n","category":"type"},{"location":"treatement/#SoleXplorer.WinFunction","page":"Multi Dimensional Treatement","title":"SoleXplorer.WinFunction","text":"WinFunction <: AbstractWinFunction\n\nCallable wrapper for windowing algorithms with parameters.\n\nFields\n\nfunc::Function: The windowing implementation function\nparams::NamedTuple: Algorithm-specific parameters\n\n\n\n\n\n","category":"type"},{"location":"treatement/#featuresets","page":"Multi Dimensional Treatement","title":"Featuresets","text":"","category":"section"},{"location":"treatement/#Basic-Statistics","page":"Multi Dimensional Treatement","title":"Basic Statistics","text":"","category":"section"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"Standard statistical measures: maximum, minimum, mean, median, std, cov","category":"page"},{"location":"treatement/#Catch22-Features","page":"Multi Dimensional Treatement","title":"Catch22 Features","text":"","category":"section"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"Canonical time-series characteristics covering:","category":"page"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"Distribution properties and extreme events\nLinear and nonlinear autocorrelation structures  \nForecasting performance and scaling properties\nSymbolic dynamics and transition patterns","category":"page"},{"location":"treatement/#Predefined-Feature-Sets","page":"Multi Dimensional Treatement","title":"Predefined Feature Sets","text":"","category":"section"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"base_set: Minimal statistical features (4 features)\ncatch9: Curated subset combining statistics + key Catch22 (9 features)  \ncatch22_set: Complete Catch22 suite (22 features)\ncomplete_set: All features combined (28 features)","category":"page"},{"location":"treatement/#References","page":"Multi Dimensional Treatement","title":"References","text":"","category":"section"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"The Catch22 features are based on the Canonical Time-series Characteristics:","category":"page"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"Repository: https://github.com/DynamicsAndNeuralSystems/catch22\nPaper: Lubba, C.H., Sethi, S.S., Knaute, P. et al. \"catch22: CAnonical Time-series CHaracteristics.\" Data Min Knowl Disc 33, 1821â€“1852 (2019). https://doi.org/10.1007/s10618-019-00647-x","category":"page"},{"location":"treatement/#SoleXplorer.base_set","page":"Multi Dimensional Treatement","title":"SoleXplorer.base_set","text":"base_set\n\nA minimal feature set containing only basic statistical measures for time series analysis.\n\nFeatures\n\nmaximum: Maximum value in the time series\nminimum: Minimum value in the time series  \nmean   : Arithmetic mean of the time series\nstd    : Standard deviation of the time series\n\n\n\n\n\n","category":"constant"},{"location":"treatement/#SoleXplorer.catch9","page":"Multi Dimensional Treatement","title":"SoleXplorer.catch9","text":"catch9\n\nA curated subset of 9 features combining basic statistics with Symbolic Catch22 measures,\n\nFeatures\n\nBasic statistics: maximum, minimum, mean, median, std\nSymbolic Catch22 features:\nstretch_high       : Measures persistence of high values\nstretch_decreasing : Captures decreasing trend patterns\nentropy_pairs      : Quantifies local pattern complexity\ntransition_variance: Measures state transition variability\n\nReferences\n\nThe Catch22 features are based on the CAnonical Time-series CHaracteristics from:\n\nRepository: https://github.com/DynamicsAndNeuralSystems/catch22\nArticle:    https://doi.org/10.1007/s10618-019-00647-x\nAuthor: Carl H. Lubba et al\n\n\n\n\n\n","category":"constant"},{"location":"treatement/#SoleXplorer.catch22_set","page":"Multi Dimensional Treatement","title":"SoleXplorer.catch22_set","text":"catch22_set\n\nThe complete Catch22 feature set. Each feature captures different aspects of time series dynamics including correlation structure, distribution properties and temporal patterns.\n\nFeature Categories\n\nDistribution shape:  mode_5, mode_10\nExtreme event timing: outlier_timing_pos, outlier_timing_neg\nLinear autocorrelation: acf_timescale, acf_first_min, low_freq_power, centroid_freq\nSimple forecasting: forecast_error\nIncremental differences: whiten_timescale, high_fluctuation\nSymbolic stretch_high, stretch_decreasing, entropy_pairs, transition_variance\nNonlinear autocorrelation: ami2, trev\nLinear autocorrelation structure: ami_timescale, periodicity\nSelf-affine scaling: rs_range, dfa\nOther: embedding_dist\n\nReferences\n\nThe Catch22 features are based on the CAnonical Time-series CHaracteristics from:\n\nRepository: https://github.com/DynamicsAndNeuralSystems/catch22\nArticle:    https://doi.org/10.1007/s10618-019-00647-x\nAuthor: Carl H. Lubba et al\n\n\n\n\n\n","category":"constant"},{"location":"treatement/#SoleXplorer.complete_set","page":"Multi Dimensional Treatement","title":"SoleXplorer.complete_set","text":"complete_set\n\nThe most comprehensive feature set combining basic statistical measures, covariance analysis, and the full Catch22 suite.\n\nFeatures\n\nBasic statistics: maximum, minimum, mean, median, std, cov\nDistribution shape:  mode_5, mode_10\nExtreme event timing: outlier_timing_pos, outlier_timing_neg\nLinear autocorrelation: acf_timescale, acf_first_min, low_freq_power, centroid_freq\nSimple forecasting: forecast_error\nIncremental differences: whiten_timescale, high_fluctuation\nSymbolic stretch_high, stretch_decreasing, entropy_pairs, transition_variance\nNonlinear autocorrelation: ami2, trev\nLinear autocorrelation structure: ami_timescale, periodicity\nSelf-affine scaling: rs_range, dfa\nOther: embedding_dist\n\n\n\n\n\n","category":"constant"},{"location":"treatement/","page":"Multi Dimensional Treatement","title":"Multi Dimensional Treatement","text":"See also: treatment, setup_dataset","category":"page"},{"location":"treatement/#All-Catch22-Features","page":"Multi Dimensional Treatement","title":"All Catch22 Features","text":"","category":"section"},{"location":"treatement/#SoleXplorer.mode_5","page":"Multi Dimensional Treatement","title":"SoleXplorer.mode_5","text":"DN_HistogramMode_5(x::AbstractVector{Union{Float64, Int}}) # For example\n\nAn alternative to catch22(:DN_HistogramMode_5](x). All features, such as DN_HistogramMode_5, are exported as Features and can be evaluated by calling their names.\n\nExamples\n\nð± = Catch22.testdata[:test]\nf = DN_HistogramMode_5(ð±)\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.mode_10","page":"Multi Dimensional Treatement","title":"SoleXplorer.mode_10","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.embedding_dist","page":"Multi Dimensional Treatement","title":"SoleXplorer.embedding_dist","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.acf_timescale","page":"Multi Dimensional Treatement","title":"SoleXplorer.acf_timescale","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.acf_first_min","page":"Multi Dimensional Treatement","title":"SoleXplorer.acf_first_min","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.ami2","page":"Multi Dimensional Treatement","title":"SoleXplorer.ami2","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.trev","page":"Multi Dimensional Treatement","title":"SoleXplorer.trev","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.outlier_timing_pos","page":"Multi Dimensional Treatement","title":"SoleXplorer.outlier_timing_pos","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.outlier_timing_neg","page":"Multi Dimensional Treatement","title":"SoleXplorer.outlier_timing_neg","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.whiten_timescale","page":"Multi Dimensional Treatement","title":"SoleXplorer.whiten_timescale","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.forecast_error","page":"Multi Dimensional Treatement","title":"SoleXplorer.forecast_error","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.ami_timescale","page":"Multi Dimensional Treatement","title":"SoleXplorer.ami_timescale","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.high_fluctuation","page":"Multi Dimensional Treatement","title":"SoleXplorer.high_fluctuation","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.stretch_decreasing","page":"Multi Dimensional Treatement","title":"SoleXplorer.stretch_decreasing","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.stretch_high","page":"Multi Dimensional Treatement","title":"SoleXplorer.stretch_high","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.entropy_pairs","page":"Multi Dimensional Treatement","title":"SoleXplorer.entropy_pairs","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.rs_range","page":"Multi Dimensional Treatement","title":"SoleXplorer.rs_range","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.dfa","page":"Multi Dimensional Treatement","title":"SoleXplorer.dfa","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.low_freq_power","page":"Multi Dimensional Treatement","title":"SoleXplorer.low_freq_power","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.centroid_freq","page":"Multi Dimensional Treatement","title":"SoleXplorer.centroid_freq","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.transition_variance","page":"Multi Dimensional Treatement","title":"SoleXplorer.transition_variance","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"treatement/#SoleXplorer.periodicity","page":"Multi Dimensional Treatement","title":"SoleXplorer.periodicity","text":"Any::DataType\n\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\n\n\n\n\n\n","category":"function"},{"location":"balancing/#balancing","page":"Balancing","title":"Balancing","text":"","category":"section"},{"location":"balancing/","page":"Balancing","title":"Balancing","text":"SoleXplorer uses the following balancing strategies taken from package Imbalance: ","category":"page"},{"location":"balancing/","page":"Balancing","title":"Balancing","text":"BorderlineSMOTE1 ClusterUndersampler ENNUndersampler ROSE RandomOversampler RandomUndersampler RandomWalkOversampler SMOTE SMOTEN SMOTENC TomekUndersampler","category":"page"},{"location":"balancing/","page":"Balancing","title":"Balancing","text":"balancing = (;\n    oversample=strategy(; kwargs...),\n    undersample=strategy(; kwargs...),\n) -> Balancing","category":"page"},{"location":"balancing/","page":"Balancing","title":"Balancing","text":"you can also tune balancing strategy parameters using tuning and ranges, i.e:","category":"page"},{"location":"balancing/","page":"Balancing","title":"Balancing","text":"r1 = SX.range(:(oversampler.k), lower=3, upper=10)\nr2 = SX.range(:(undersampler.min_ratios), lower=0.1, upper=0.9)\nmodelc = symbolic_analysis(\n    Xc, yc;\n    model=RandomForestClassifier(),\n    resampling=StratifiedCV(nfolds=5, shuffle=true),\n    balancing=(\n        oversampler=SMOTENC(k=5, ratios=1.0),\n        undersampler=TomekUndersampler(min_ratios=0.5)),\n    tuning=GridTuning(goal=4, range=(r1,r2)),\n    measures=(accuracy, )\n)","category":"page"},{"location":"#SoleXplorer","page":"Home","title":"SoleXplorer","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleXplorer, an interactive interface for exploring symbolic machine learning models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Built on top of the Sole.jl ecosystem. It provides tools for visualizing, inspecting, and interacting with models derived from (logic-based) symbolic learning algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Can handle both classification and regression tasks.\nInspect metrics.\nWorks also on time-series based datasets using modal logic.\nView rules and their metrics.\nInspect logical formulas and their evaluation.\nView modal rule associations.\nIntegrated GUI.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add SoleXplorer","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Decision-tree","page":"Home","title":"Decision tree","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Every parameter is defaulted: start analysis simply passing your raw dataset:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SoleXplorer, MLJ\n\n# Load example dataset\nXc, yc = @load_iris\n\n# Train a decision tree\nmodelc = symbolic_analysis(Xc, yc)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, customizations are possible:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Random\n\nrange = SoleXplorer.range(:min_purity_increase; lower=0.001, upper=1.0, scale=:log)\nmodelc = symbolic_analysis(\n    Xc, yc;\n    model=DecisionTreeClassifier(),\n    resampling=CV(nfolds=5, shuffle=true),\n    seed=1,\n    tuning=(tuning=Grid(resolution=10), resampling=CV(nfolds=3), range, measure=accuracy, repeats=2),\n    extractor=InTreesRuleExtractor(),\n    measures=(accuracy, log_loss, confusion_matrix, kappa)      \n)","category":"page"},{"location":"#Temporal-association-rules","page":"Home","title":"Temporal association rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Load a temporal dataset\nnatopsloader = NatopsLoader()\nXts, yts = SoleXplorer.load(natopsloader)\n\n# Train a modal decision tree\nmodelts = symbolic_analysis(\n    Xts, yts;\n    model=ModalDecisionTree(),\n    resampling=Holdout(fraction_train=0.8, shuffle=true),\n    seed=1,\n    features=(minimum, maximum),\n    measures=(log_loss, accuracy, confusion_matrix, kappa)\n)","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleXplorer extensively uses the following packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SoleLogics: modal and temporal logic systems.\nMLJ: provides all machine learning frameworks.\nSolePostHoc: for rule extraction.\nModalAssociationRules: for mining association rules.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"}]
}
